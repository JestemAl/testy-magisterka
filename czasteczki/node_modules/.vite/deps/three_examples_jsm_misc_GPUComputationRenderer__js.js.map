{
  "version": 3,
  "sources": ["../../three/examples/jsm/postprocessing/Pass.js", "../../three/examples/jsm/misc/GPUComputationRenderer.js"],
  "sourcesContent": ["import {\r\n\tBufferGeometry,\r\n\tFloat32BufferAttribute,\r\n\tOrthographicCamera,\r\n\tMesh\r\n} from 'three';\r\n\r\nclass Pass {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.isPass = true;\r\n\r\n\t\t// if set to true, the pass is processed by the composer\r\n\t\tthis.enabled = true;\r\n\r\n\t\t// if set to true, the pass indicates to swap read and write buffer after rendering\r\n\t\tthis.needsSwap = true;\r\n\r\n\t\t// if set to true, the pass clears its buffer before rendering\r\n\t\tthis.clear = false;\r\n\r\n\t\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\r\n\t\tthis.renderToScreen = false;\r\n\r\n\t}\r\n\r\n\tsetSize( /* width, height */ ) {}\r\n\r\n\trender( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\r\n\r\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\r\n\r\n\t}\r\n\r\n\tdispose() {}\r\n\r\n}\r\n\r\n// Helper for passes that need to fill the viewport with a single quad.\r\n\r\nconst _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\r\n// https://github.com/mrdoob/three.js/pull/21358\r\n\r\nclass FullscreenTriangleGeometry extends BufferGeometry {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\r\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );\r\n\r\n\t}\r\n\r\n}\r\n\r\nconst _geometry = new FullscreenTriangleGeometry();\r\n\r\nclass FullScreenQuad {\r\n\r\n\tconstructor( material ) {\r\n\r\n\t\tthis._mesh = new Mesh( _geometry, material );\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis._mesh.geometry.dispose();\r\n\r\n\t}\r\n\r\n\trender( renderer ) {\r\n\r\n\t\trenderer.render( this._mesh, _camera );\r\n\r\n\t}\r\n\r\n\tget material() {\r\n\r\n\t\treturn this._mesh.material;\r\n\r\n\t}\r\n\r\n\tset material( value ) {\r\n\r\n\t\tthis._mesh.material = value;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { Pass, FullScreenQuad };\r\n", "import {\r\n\tClampToEdgeWrapping,\r\n\tDataTexture,\r\n\tFloatType,\r\n\tNearestFilter,\r\n\tRGBAFormat,\r\n\tShaderMaterial,\r\n\tWebGLRenderTarget\r\n} from 'three';\r\n\r\nimport { FullScreenQuad } from '../postprocessing/Pass.js';\r\n\r\n/**\r\n * GPUComputationRenderer, based on SimulationRenderer by zz85\r\n *\r\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\r\n * for each compute element (texel)\r\n *\r\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\r\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\r\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\r\n *\r\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\r\n * as inputs to render the textures of the next frame.\r\n *\r\n * The render targets of the variables can be used as input textures for your visualization shaders.\r\n *\r\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\r\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\r\n *\r\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\r\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\r\n *\r\n * -------------\r\n *\r\n * Basic use:\r\n *\r\n * // Initialization...\r\n *\r\n * // Create computation renderer\r\n * const gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\r\n *\r\n * // Create initial state float textures\r\n * const pos0 = gpuCompute.createTexture();\r\n * const vel0 = gpuCompute.createTexture();\r\n * // and fill in here the texture data...\r\n *\r\n * // Add texture variables\r\n * const velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, pos0 );\r\n * const posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, vel0 );\r\n *\r\n * // Add variable dependencies\r\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\r\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\r\n *\r\n * // Add custom uniforms\r\n * velVar.material.uniforms.time = { value: 0.0 };\r\n *\r\n * // Check for completeness\r\n * const error = gpuCompute.init();\r\n * if ( error !== null ) {\r\n *\t\tconsole.error( error );\r\n  * }\r\n *\r\n *\r\n * // In each frame...\r\n *\r\n * // Compute!\r\n * gpuCompute.compute();\r\n *\r\n * // Update texture uniforms in your visualization materials with the gpu renderer output\r\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\r\n *\r\n * // Do your rendering\r\n * renderer.render( myScene, myCamera );\r\n *\r\n * -------------\r\n *\r\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\r\n * Note that the shaders can have multiple input textures.\r\n *\r\n * const myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\r\n * const myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\r\n *\r\n * const inputTexture = gpuCompute.createTexture();\r\n *\r\n * // Fill in here inputTexture...\r\n *\r\n * myFilter1.uniforms.theTexture.value = inputTexture;\r\n *\r\n * const myRenderTarget = gpuCompute.createRenderTarget();\r\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\r\n *\r\n * const outputRenderTarget = gpuCompute.createRenderTarget();\r\n *\r\n * // Now use the output texture where you want:\r\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\r\n *\r\n * // And compute each frame, before rendering to screen:\r\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\r\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\r\n *\r\n *\r\n *\r\n * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.\r\n * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.\r\n * @param {WebGLRenderer} renderer The renderer\r\n  */\r\n\r\nclass GPUComputationRenderer {\r\n\r\n\tconstructor( sizeX, sizeY, renderer ) {\r\n\r\n\t\tthis.variables = [];\r\n\r\n\t\tthis.currentTextureIndex = 0;\r\n\r\n\t\tlet dataType = FloatType;\r\n\r\n\t\tconst passThruUniforms = {\r\n\t\t\tpassThruTexture: { value: null }\r\n\t\t};\r\n\r\n\t\tconst passThruShader = createShaderMaterial( getPassThroughFragmentShader(), passThruUniforms );\r\n\r\n\t\tconst quad = new FullScreenQuad( passThruShader );\r\n\r\n\t\tthis.setDataType = function ( type ) {\r\n\r\n\t\t\tdataType = type;\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t\tthis.addVariable = function ( variableName, computeFragmentShader, initialValueTexture ) {\r\n\r\n\t\t\tconst material = this.createShaderMaterial( computeFragmentShader );\r\n\r\n\t\t\tconst variable = {\r\n\t\t\t\tname: variableName,\r\n\t\t\t\tinitialValueTexture: initialValueTexture,\r\n\t\t\t\tmaterial: material,\r\n\t\t\t\tdependencies: null,\r\n\t\t\t\trenderTargets: [],\r\n\t\t\t\twrapS: null,\r\n\t\t\t\twrapT: null,\r\n\t\t\t\tminFilter: NearestFilter,\r\n\t\t\t\tmagFilter: NearestFilter\r\n\t\t\t};\r\n\r\n\t\t\tthis.variables.push( variable );\r\n\r\n\t\t\treturn variable;\r\n\r\n\t\t};\r\n\r\n\t\tthis.setVariableDependencies = function ( variable, dependencies ) {\r\n\r\n\t\t\tvariable.dependencies = dependencies;\r\n\r\n\t\t};\r\n\r\n\t\tthis.init = function () {\r\n\r\n\t\t\tif ( renderer.capabilities.maxVertexTextures === 0 ) {\r\n\r\n\t\t\t\treturn 'No support for vertex shader textures.';\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( let i = 0; i < this.variables.length; i ++ ) {\r\n\r\n\t\t\t\tconst variable = this.variables[ i ];\r\n\r\n\t\t\t\t// Creates rendertargets and initialize them with input texture\r\n\t\t\t\tvariable.renderTargets[ 0 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\r\n\t\t\t\tvariable.renderTargets[ 1 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\r\n\t\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 0 ] );\r\n\t\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 1 ] );\r\n\r\n\t\t\t\t// Adds dependencies uniforms to the ShaderMaterial\r\n\t\t\t\tconst material = variable.material;\r\n\t\t\t\tconst uniforms = material.uniforms;\r\n\r\n\t\t\t\tif ( variable.dependencies !== null ) {\r\n\r\n\t\t\t\t\tfor ( let d = 0; d < variable.dependencies.length; d ++ ) {\r\n\r\n\t\t\t\t\t\tconst depVar = variable.dependencies[ d ];\r\n\r\n\t\t\t\t\t\tif ( depVar.name !== variable.name ) {\r\n\r\n\t\t\t\t\t\t\t// Checks if variable exists\r\n\t\t\t\t\t\t\tlet found = false;\r\n\r\n\t\t\t\t\t\t\tfor ( let j = 0; j < this.variables.length; j ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( depVar.name === this.variables[ j ].name ) {\r\n\r\n\t\t\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( ! found ) {\r\n\r\n\t\t\t\t\t\t\t\treturn 'Variable dependency not found. Variable=' + variable.name + ', dependency=' + depVar.name;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tuniforms[ depVar.name ] = { value: null };\r\n\r\n\t\t\t\t\t\tmaterial.fragmentShader = '\\nuniform sampler2D ' + depVar.name + ';\\n' + material.fragmentShader;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.currentTextureIndex = 0;\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t};\r\n\r\n\t\tthis.compute = function () {\r\n\r\n\t\t\tconst currentTextureIndex = this.currentTextureIndex;\r\n\t\t\tconst nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\r\n\r\n\t\t\tfor ( let i = 0, il = this.variables.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tconst variable = this.variables[ i ];\r\n\r\n\t\t\t\t// Sets texture dependencies uniforms\r\n\t\t\t\tif ( variable.dependencies !== null ) {\r\n\r\n\t\t\t\t\tconst uniforms = variable.material.uniforms;\r\n\r\n\t\t\t\t\tfor ( let d = 0, dl = variable.dependencies.length; d < dl; d ++ ) {\r\n\r\n\t\t\t\t\t\tconst depVar = variable.dependencies[ d ];\r\n\r\n\t\t\t\t\t\tuniforms[ depVar.name ].value = depVar.renderTargets[ currentTextureIndex ].texture;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Performs the computation for this variable\r\n\t\t\t\tthis.doRenderTarget( variable.material, variable.renderTargets[ nextTextureIndex ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.currentTextureIndex = nextTextureIndex;\r\n\r\n\t\t};\r\n\r\n\t\tthis.getCurrentRenderTarget = function ( variable ) {\r\n\r\n\t\t\treturn variable.renderTargets[ this.currentTextureIndex ];\r\n\r\n\t\t};\r\n\r\n\t\tthis.getAlternateRenderTarget = function ( variable ) {\r\n\r\n\t\t\treturn variable.renderTargets[ this.currentTextureIndex === 0 ? 1 : 0 ];\r\n\r\n\t\t};\r\n\r\n\t\tthis.dispose = function () {\r\n\r\n\t\t\tquad.dispose();\r\n\r\n\t\t\tconst variables = this.variables;\r\n\r\n\t\t\tfor ( let i = 0; i < variables.length; i ++ ) {\r\n\r\n\t\t\t\tconst variable = variables[ i ];\r\n\r\n\t\t\t\tif ( variable.initialValueTexture ) variable.initialValueTexture.dispose();\r\n\r\n\t\t\t\tconst renderTargets = variable.renderTargets;\r\n\r\n\t\t\t\tfor ( let j = 0; j < renderTargets.length; j ++ ) {\r\n\r\n\t\t\t\t\tconst renderTarget = renderTargets[ j ];\r\n\t\t\t\t\trenderTarget.dispose();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tfunction addResolutionDefine( materialShader ) {\r\n\r\n\t\t\tmaterialShader.defines.resolution = 'vec2( ' + sizeX.toFixed( 1 ) + ', ' + sizeY.toFixed( 1 ) + ' )';\r\n\r\n\t\t}\r\n\r\n\t\tthis.addResolutionDefine = addResolutionDefine;\r\n\r\n\r\n\t\t// The following functions can be used to compute things manually\r\n\r\n\t\tfunction createShaderMaterial( computeFragmentShader, uniforms ) {\r\n\r\n\t\t\tuniforms = uniforms || {};\r\n\r\n\t\t\tconst material = new ShaderMaterial( {\r\n\t\t\t\tname: 'GPUComputationShader',\r\n\t\t\t\tuniforms: uniforms,\r\n\t\t\t\tvertexShader: getPassThroughVertexShader(),\r\n\t\t\t\tfragmentShader: computeFragmentShader\r\n\t\t\t} );\r\n\r\n\t\t\taddResolutionDefine( material );\r\n\r\n\t\t\treturn material;\r\n\r\n\t\t}\r\n\r\n\t\tthis.createShaderMaterial = createShaderMaterial;\r\n\r\n\t\tthis.createRenderTarget = function ( sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter ) {\r\n\r\n\t\t\tsizeXTexture = sizeXTexture || sizeX;\r\n\t\t\tsizeYTexture = sizeYTexture || sizeY;\r\n\r\n\t\t\twrapS = wrapS || ClampToEdgeWrapping;\r\n\t\t\twrapT = wrapT || ClampToEdgeWrapping;\r\n\r\n\t\t\tminFilter = minFilter || NearestFilter;\r\n\t\t\tmagFilter = magFilter || NearestFilter;\r\n\r\n\t\t\tconst renderTarget = new WebGLRenderTarget( sizeXTexture, sizeYTexture, {\r\n\t\t\t\twrapS: wrapS,\r\n\t\t\t\twrapT: wrapT,\r\n\t\t\t\tminFilter: minFilter,\r\n\t\t\t\tmagFilter: magFilter,\r\n\t\t\t\tformat: RGBAFormat,\r\n\t\t\t\ttype: dataType,\r\n\t\t\t\tdepthBuffer: false\r\n\t\t\t} );\r\n\r\n\t\t\treturn renderTarget;\r\n\r\n\t\t};\r\n\r\n\t\tthis.createTexture = function () {\r\n\r\n\t\t\tconst data = new Float32Array( sizeX * sizeY * 4 );\r\n\t\t\tconst texture = new DataTexture( data, sizeX, sizeY, RGBAFormat, FloatType );\r\n\t\t\ttexture.needsUpdate = true;\r\n\t\t\treturn texture;\r\n\r\n\t\t};\r\n\r\n\t\tthis.renderTexture = function ( input, output ) {\r\n\r\n\t\t\t// Takes a texture, and render out in rendertarget\r\n\t\t\t// input = Texture\r\n\t\t\t// output = RenderTarget\r\n\r\n\t\t\tpassThruUniforms.passThruTexture.value = input;\r\n\r\n\t\t\tthis.doRenderTarget( passThruShader, output );\r\n\r\n\t\t\tpassThruUniforms.passThruTexture.value = null;\r\n\r\n\t\t};\r\n\r\n\t\tthis.doRenderTarget = function ( material, output ) {\r\n\r\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\r\n\r\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\r\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\r\n\r\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification\r\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\r\n\t\t\tquad.material = material;\r\n\t\t\trenderer.setRenderTarget( output );\r\n\t\t\tquad.render( renderer );\r\n\t\t\tquad.material = passThruShader;\r\n\r\n\t\t\trenderer.xr.enabled = currentXrEnabled;\r\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\r\n\r\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\r\n\r\n\t\t};\r\n\r\n\t\t// Shaders\r\n\r\n\t\tfunction getPassThroughVertexShader() {\r\n\r\n\t\t\treturn\t'void main()\t{\\n' +\r\n\t\t\t\t\t'\\n' +\r\n\t\t\t\t\t'\tgl_Position = vec4( position, 1.0 );\\n' +\r\n\t\t\t\t\t'\\n' +\r\n\t\t\t\t\t'}\\n';\r\n\r\n\t\t}\r\n\r\n\t\tfunction getPassThroughFragmentShader() {\r\n\r\n\t\t\treturn\t'uniform sampler2D passThruTexture;\\n' +\r\n\t\t\t\t\t'\\n' +\r\n\t\t\t\t\t'void main() {\\n' +\r\n\t\t\t\t\t'\\n' +\r\n\t\t\t\t\t'\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n' +\r\n\t\t\t\t\t'\\n' +\r\n\t\t\t\t\t'\tgl_FragColor = texture2D( passThruTexture, uv );\\n' +\r\n\t\t\t\t\t'\\n' +\r\n\t\t\t\t\t'}\\n';\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { GPUComputationRenderer };\r\n"],
  "mappings": "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",
  "names": []
}
